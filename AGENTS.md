# AGENTS.md

このドキュメントは、コーディングエージェントが本リポジトリを安全に変更するための **最小ルール** を定義する。

---

## 1. 機能

本アプリの目的は、**ユーザーがスプラトゥーン 3 のプレイ映像を手間なく記録すること** である。

### 1.1 セットアップ機能

**目的**: ユーザーが迷わず簡単にアプリを使える状態にすること

以下の項目を対話的にセットアップする：

- 関連アプリのインストール（OBS Studio、FFmpeg 等）
- OBS Studio の設定（録画設定、仮想カメラ等）
- キャプチャデバイスの選択と設定
- YouTube API 認証（オプション）
- その他必要な初期設定

### 1.2 メイン機能

**目的**: ユーザーは基本的にプレイするだけでよい

#### 録画機能

- 画面状態を自動判定（バトル開始・終了、リザルト画面等）
- メタ情報の自動抽出（ステージ、ルール、勝敗、キルデス等）
- 自動録画開始・終了

#### 編集機能

- スケジュール毎に動画を結合
- サムネイル画像の自動生成
- タイトル・説明文の自動生成

#### アップロード機能

- YouTube への自動アップロード

#### その他

- 終了後の自動スリープ（オプション）
- アプリの設定
- 録画データの編集 (メタデータ編集、字幕編集)

### 1.3 ランタイム / ツールチェーン

- OS / Shell: Windows 11 + PowerShell
- Python: `backend/.python-version` 記載バージョンに追随
- 仮想環境: `backend/.venv` を有効化後 `backend/` で `uv sync`
- Node.js / npm: `frontend/` で `npm install`

---

## 2. アーキテクチャ

本アプリの設計目標は、**アプリを安定的に稼働させ、将来の機能追加や保守を素早く対応できること** である。

**基本方針**：

- すべての変更は **Clean Architecture の原則に準拠** する
- **後方互換性を考慮せず根本的な解決を目指す**
- 技術的負債は妥協せず、設計の問題は設計で解決する

### 2.1 エージェント行動原則

以下は、エージェントが変更を行う際の **思考順序と判断優先度** を定義する行動原則である。

#### 原則 0：**本質的に考える**（最優先原則）

- **表面的な症状ではなく、根本原因を追求する**
- **「なぜ」を 3 回繰り返す** - 問題の本質が見えるまで深掘りする
- **命名・構造・パターンの意図を問う** - 意図が不明確なら、それ自体が設計の問題
- **一時的な対処ではなく、恒久的な解決を目指す**
- **「意味のある要素」を保持する** - 数値（60 秒=1 分）、命名（UserRepository）、構造（レイヤ分離）など
- **変更の影響範囲を予測する** - 一つの変更が他のコードの前提を壊していないか確認する

**変更時の行動指針**：

- **既存の値や名前の意図を問う** - なぜその数値なのか、なぜその命名なのかを理解してから変更する
- **複合的な意図は分解する** - 複数の要素（基準値 + 調整値）を組み合わせる場合、それぞれを明示する
- **計算式で関係性を表現する** - `A + B = C` のように、結果がどう導かれるかを明確にする
- **元の意図を失わない** - 変更後も、元のコードが持っていた本質的な意図が読み取れるようにする

#### 原則 1：変更前に「何をしているコードか」を言語化する

- 変更対象について、責務（役割）・所属レイヤ（domain / application / interface / infrastructure）・主な呼び出し元を把握する
- それらが説明できない場合、大きな変更や構造変更は行わず、まず調査を優先する

#### 原則 2：設計判断がある場合は独断で確定しない

- 複数の設計案が考えられる場合、少なくとも 2 案を意識する
- 各案のトレードオフ（利点・欠点・影響範囲）を簡潔に整理する
- 前提情報が不足している、または正解が一意に定まらない場合は、人間の判断に委ねる
- **表面的な技術選択ではなく、設計の本質的なトレードオフを考える**

#### 原則 3：既存実装を尊重しつつ、問題があれば「提案」として示す

- 既存実装には意図がある前提で扱い、不用意に設計を塗り替えない
- ただし、一般的なベストプラクティスや慣習に明確に反している場合は、修正を押し付けず提案として可視化する
- 提案には以下を含める

  - 問題点（将来起きうる不具合・保守コスト）
  - 改善案（1〜2 案）
  - 影響範囲（どこが変わるか）

#### 原則 4：将来の変更者（人間）を前提に書く

- 数か月後に第三者が読む前提でコードとコメントを書く
- コメントは「何をしているか」ではなく「なぜそうしているか」を記載する
- 一時的な前提や制約がある場合は、将来的な解消方針も示す

#### 原則 5：迷ったら"止まる"ことを許可する

- 次のような状況では、無理に完結させず判断材料を提示して止まる

  - 仕様が未確定、または曖昧な場合
  - 外部依存（API / 環境差）による挙動が読めない場合
  - 影響範囲が広く、安全性を担保できない場合

- 止まる際は、以下を簡潔に示す

  - 不明点・仮定
  - 考えられる選択肢
  - 次に必要な情報

### 2.2 設計方針

**設計判断の優先順位**：

1. **ビジネスルールの独立性** - ドメイン層は外部要因から完全に独立
2. **依存性の逆転** - 抽象（ポート）に依存、具象（アダプタ）には依存しない
3. **テスタビリティ** - すべてのコンポーネントは単体テスト可能
4. **変更容易性** - 要件変更時の影響範囲を最小化

**基本原則（全層共通）**：

- **単一責任原則（SRP）**: 1 つのクラス/モジュールは 1 つの責務のみを持つ
- **依存性の逆転原則（DIP）**: 具象ではなく抽象（ポート）に依存する
- **開放閉鎖原則（OCP）**: 拡張に対して開いており、修正に対して閉じている
- **インターフェース分離原則（ISP）**: 使用しないメソッドへの依存を強制しない

#### 2.2.1 レイヤ依存

- 依存方向: `interface → application → domain`
- `infrastructure` はポート実装として **DI により注入**
- ビジネスルールは外部要因（I/O・FW・DB・UI）から独立させる

**各層の詳細ガイドラインは各層の `AGENTS.md` を参照**：

- `backend/src/splat_replay/domain/AGENTS.md` - ドメイン層の実装ルール
- `backend/src/splat_replay/application/AGENTS.md` - アプリケーション層の実装ルール
- `backend/src/splat_replay/infrastructure/AGENTS.md` - インフラ層の実装ルール
- `backend/src/splat_replay/interface/AGENTS.md` - インターフェース層の実装ルール

#### 2.2.2 Import 制約

- `backend/src/splat_replay/domain` は他の全レイヤー（application / infrastructure / interface）を import 禁止
- `backend/src/splat_replay/application` は `infrastructure` / `interface` を import 禁止
- `backend/src/splat_replay/infrastructure` は `interface` を import 禁止
- `backend/src/splat_replay/interface` は application のユースケース呼び出しのみ（infrastructure 直接参照禁止）

#### 2.2.3 Bootstrap（Composition Root）

- `backend/src/splat_replay/bootstrap` は Composition Root として、interface / infrastructure / application / domain を組み立てるための場所
- bootstrap 以外の各レイヤーから bootstrap を import しない（依存は一方向）
- エントリポイント（CLI / Web / WebView / 開発サーバー）は bootstrap から提供する

### 2.3 品質ルール

#### 2.3.1 型・安全性

- **Backend（Python）**: 型注釈 100% 必須（暗黙の Any を作らない）
- **Frontend（TypeScript）**: `any` を避け、型で表現する
- 公式型が無い場合のみ `typings/` に最小限の型スタブを追加する

#### 2.3.2 コードサイズと分割

**推奨サイズ（目安）**：

- 1 ファイル: 500 行以下
- 1 クラス/モジュール: 200〜300 行程度
- 1 メソッド/関数: 20〜30 行程度

これらは **あくまで目安** であり、絶対的な基準ではない。最終的な判断基準は以下を優先する：

- **単一責任原則（SRP）**: 1 つの責務に集中しているか
- **テスタビリティ**: 単体テストが書きやすいか
- **保守性**: 数か月後に読んで理解しやすいか

#### 2.3.3 命名規則と可読性

- 略語の使用を避ける（数週間後に読む人が理解しやすい）
- 型名と変数名は本質的な意図を表現する
- 属性名は役割を明確にする
- **命名で迷ったら、それは責務が曖昧な証拠** - 責務を明確にしてから命名する

#### 2.3.4 フォーマット / Lint / 静的解析

- フォーマッター / リンター / 静的解析の警告・エラーは、まず **設計・実装の改善シグナル** として扱う
- 可能な限り **根本原因の解消（設計/実装の修正）** を優先する

**例外（抑制・無効化）が必要な場合**：

- `# noqa` / `# type: ignore` / `eslint-disable` 等の抑制は **最後の手段** とする
- 導入する場合は、該当箇所に **理由と将来の解消方針** をコメントで残す
- ルール緩和（設定変更）での解決は原則しない（必要なら人間へ提案し、判断材料を添える）

### 2.4 作業フロー

#### 2.4.1 着手前

1. リポジトリルート確認（`pwd` / `Get-Location`）
2. 仮想環境有効化 → `backend/` で `uv sync`
3. 既存ポート・型定義・ユースケースの再利用可否を確認
4. 既存の仕様を把握・変更影響範囲を確認

#### 2.4.2 PR 前（必須）

以下を実行して品質を担保する：

- 一時 / デバッグコード削除
- フォーマッター / リンター / 静的解析実行・修正

**すべてまとめて実行（推奨）**:

```bash
task verify  # Backend + Frontend の format / lint / type-check / test をすべて実行
```

**個別に実行する場合**:

```bash
task format      # Backend + Frontend のフォーマット
task lint        # Backend + Frontend のリント
task type-check  # Backend + Frontend の型チェック
task test        # Backend のテスト
```

または各層ごとに実行:

```bash
# Backend のみ
task format:backend
task lint:backend
task type-check:backend
task test

# Frontend のみ
task format:frontend
task lint:frontend
task type-check:frontend
```

### 2.5 禁止事項（明確に NG）

- `pip install` やグローバル環境前提
- レイヤ逆依存 import
- 主要ループへ長時間ブロッキング I/O を直書き
- 高頻度ループ内の過剰ログ
- 「編集理由だけ」を残すコメント
- フォーマッター / リンター / 静的解析の警告・エラーを放置
